#version 450

uniform float uTime;

// hueshift function adapted from user mAlk:
// https://www.shadertoy.com/view/MsjXRt
vec4 hueshift(in vec3 Color, in float Shift)
{
    vec3 P = vec3(0.55735) * dot(vec3(0.55735), Color);
    vec3 U = Color - P;
    vec3 V = cross(vec3(0.55735), U);
    
    Color = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;
    return vec4(Color, 1.0);
}

// going off of here so far:
// https://developer.arm.com/documentation/100587/0100/compute-shaders/compute-shaders-example
struct SimulationData
{
		vec4 position;
        vec4 velocity;
};

struct VertexDisplayData
{
		vec4 position;
        vec4 color;
};

// buffer for managing particles in VS
layout(std430, binding = 0) writeonly buffer destBuffer
{
        VertexDisplayData data[];
} ParticleOut;

// 
layout(std430, binding = 1) buffer calcBuffer
{
        SimulationData data[];
} ParticleCalc;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Apply velocity to a particle's position
void calculatePosition(in vec4 inPosition, in vec4 velocity, out vec4 outPosition)
{
	
	outPosition = vec4(inPosition.xyz + velocity.xyz, inPosition.w);
	
}

void main()
{
	
	// get simulation data from last frame
	uint storePos = gl_GlobalInvocationID.x;
	
	// simulate each particle one more step
	calculatePosition(ParticleCalc.data[storePos].position, ParticleCalc.data[storePos].velocity, ParticleCalc.data[storePos].position);
	
	// write particle position and color to output buffer
	
	
	
	
	//ParticleOut.data[storePos].velocity = vec4(1.0, 1.0, 1.0, 1.0);
	float t = mod((uTime * 1.0) + storePos, 250.0);
	/*float x = t * sin(t * 1.0) * 0.05;
	float y = t * 0.06;
	float z = t * cos(t * 1.0) * 0.05;
	ParticleOut.data[storePos].position = vec4(x, y, z, 1.0);*/
	
	// color
	ParticleOut.data[storePos].color = hueshift(vec3(1.0, 0.0, 0.0), t * 0.002 + uTime * 0.2);
}