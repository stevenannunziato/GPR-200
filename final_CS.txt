#version 450

uniform float uTime;
uniform float uDeltaTime;

// hueshift function adapted from user mAlk:
// https://www.shadertoy.com/view/MsjXRt
vec4 hueshift(in vec3 Color, in float Shift)
{
    vec3 P = vec3(0.55735) * dot(vec3(0.55735), Color);
    vec3 U = Color - P;
    vec3 V = cross(vec3(0.55735), U);
    
    Color = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;
    return vec4(Color, 1.0);
}

// going off of here so far:
// https://developer.arm.com/documentation/100587/0100/compute-shaders/compute-shaders-example
struct SimulationData
{
		vec4 position;
        vec4 velocity;
};

struct VertexDisplayData
{
		vec4 position;
        vec4 color;
};

// buffer for managing particles in VS
layout(std430, binding = 0) writeonly buffer destBuffer
{
        VertexDisplayData data[];
} ParticleOut;

// 
layout(std430, binding = 1) buffer calcBuffer
{
        SimulationData data[];
} ParticleCalc;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;




// simulation functions -------------------------------------------------------------------------------

void checkLifetime(inout vec4 prevPos, inout vec4 prevVel, in uint index) {

	float maxLifetime = 5.0;
	vec3 defaultPosition = vec3(cos(index) * 5.0, sin(prevPos.x), sin(index) * 5.0);
	
	prevPos.w += uDeltaTime;
	if (prevPos.w > maxLifetime) {
		prevPos = vec4(defaultPosition, 0.0);
		prevVel = vec4(0.0);
	}
	
}

vec4 calcVelocity(in vec4 inPos)
{
	
	vec4 result = inPos;
	return result;

}

// Apply velocity to a particle's position
void calculatePosition(in vec4 inPosition, inout vec4 velocity, out vec4 outPosition)
{
	
	outPosition = vec4(inPosition.xyz + velocity.xyz, inPosition.w);
	
}

void main()
{
	
	// get simulation data from last frame -------------------------------------------------
	uint storePos = gl_GlobalInvocationID.x;
	
	// simulate each particle one more step ------------------------------------------------
	
	// get simulation data from last frame
	vec4 prevPos = ParticleCalc.data[storePos].position;
	vec4 prevVel = ParticleCalc.data[storePos].velocity;
	vec4 newPos;
	
	// handle particle lifetime
	checkLifetime(prevPos, prevVel, storePos);
	
	// set new velocity and position
	// set velocity based on vector field
	ParticleCalc.data[storePos].velocity = calcVelocity(prevPos) * 0.001;
	// ensure w component is 1
	ParticleCalc.data[storePos].velocity.w = 1.0;
	// add velocity to position
	calculatePosition(prevPos, prevVel, newPos);
	ParticleCalc.data[storePos].position = newPos;
	
	// write particle position and color to output buffer -----------------------------------
	ParticleOut.data[storePos].position = ParticleCalc.data[storePos].position;
	
	//ParticleOut.data[storePos].velocity = vec4(1.0, 1.0, 1.0, 1.0);
	float t = mod((uTime * 1.0) + storePos, 250.0);
	/*float x = t * sin(t * 1.0) * 0.05;
	float y = t * 0.06;
	float z = t * cos(t * 1.0) * 0.05;
	ParticleOut.data[storePos].position = vec4(x, y, z, 1.0);*/
	
	// color
	ParticleOut.data[storePos].color = hueshift(vec3(1.0, 0.0, 0.0), t * 0.002 + uTime * 0.2);
}