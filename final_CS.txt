#version 450

uniform float uTime;
uniform float uDeltaTime;

// structure for position last frame
struct SimulationData
{
		vec4 position;
};

// structure for displaying output of each particle
struct VertexDisplayData
{
		vec4 position;
        vec4 color;
};

// buffer for managing particles in VS output
layout(std430, binding = 0) writeonly buffer destBuffer
{
        VertexDisplayData data[];
} ParticleOut;

// buffer for simulating particles
layout(std430, binding = 1) buffer calcBuffer
{
        SimulationData data[];
} ParticleCalc;

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

// utility functions ------------------------------------------------------------

// hueshift function adapted from user mAlk:
// https://www.shadertoy.com/view/MsjXRt
vec4 hueshift(in vec3 Color, in float Shift)
{
    vec3 P = vec3(0.55735) * dot(vec3(0.55735), Color);
    vec3 U = Color - P;
    vec3 V = cross(vec3(0.55735), U);
    
    Color = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;
    return vec4(Color, 1.0);
}

// random function adapted from here:
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// simplex noise adapted from here:
// https://www.shadertoy.com/view/XsX3zB
/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */
vec3 random3(vec3 c) {
	float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
	vec3 r;
	r.z = fract(512.0*j);
	j *= .125;
	r.x = fract(512.0*j);
	j *= .125;
	r.y = fract(512.0*j);
	return r-0.5;
}

/* skew constants for 3d simplex functions */
const float F3 =  0.3333333;
const float G3 =  0.1666667;

// simplex noise adapted from here:
// https://www.shadertoy.com/view/XsX3zB
/* 3d simplex noise */
float simplex3d(vec3 p) {
	 /* 1. find current tetrahedron T and it's four vertices */
	 /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
	 /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/
	 
	 /* calculate s and x */
	 vec3 s = floor(p + dot(p, vec3(F3)));
	 vec3 x = p - s + dot(s, vec3(G3));
	 
	 /* calculate i1 and i2 */
	 vec3 e = step(vec3(0.0), x - x.yzx);
	 vec3 i1 = e*(1.0 - e.zxy);
	 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
	 	
	 /* x1, x2, x3 */
	 vec3 x1 = x - i1 + G3;
	 vec3 x2 = x - i2 + 2.0*G3;
	 vec3 x3 = x - 1.0 + 3.0*G3;
	 
	 /* 2. find four surflets and store them in d */
	 vec4 w, d;
	 
	 /* calculate surflet weights */
	 w.x = dot(x, x);
	 w.y = dot(x1, x1);
	 w.z = dot(x2, x2);
	 w.w = dot(x3, x3);
	 
	 /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
	 w = max(0.6 - w, 0.0);
	 
	 /* calculate surflet components */
	 d.x = dot(random3(s), x);
	 d.y = dot(random3(s + i1), x1);
	 d.z = dot(random3(s + i2), x2);
	 d.w = dot(random3(s + 1.0), x3);
	 
	 /* multiply d by w^4 */
	 w *= w;
	 w *= w;
	 d *= w;
	 
	 /* 3. return the sum of the four surflets */
	 return dot(d, vec4(52.0));
}

// returns a vec3 with pseudo-random noise function
vec4 simplexNoise(in vec4 point, in float scrollSpeed, in float frequency, in vec3 intensity)
{
	// generate a value noise from 3D input
	vec3 noise = vec3(simplex3d(point.xyz * frequency + scrollSpeed * uTime));
	
	// scale output based on intensity
	noise *= intensity;
	
	// finalize output
	return vec4(vec3(noise), point.w);
}


// simulation functions -------------------------------------------------------------------------------

void checkLifetime(inout vec4 prevPos, inout vec4 prevVel, in uint index, in vec3 defaultPosition, out float r) {

	// define a max lifetime
	float maxLifetime = 6.0;
	// define pseudo-random value [0, maxLifetime - 1)
	r = rand(vec2(index)) * 20;
	r = mod(r, maxLifetime - 1.0);
	
	// increment lifetime
	prevPos.w += uDeltaTime;
	if (prevPos.w > maxLifetime) {
		// reset particle
		prevPos = vec4(defaultPosition, r); // r is an offset to ensure asynchronous spawning
		prevVel = vec4(0.0);
	}
}

// vector field for explosion
vec4 radialVectorField(in vec4 inPos)
{
	// pass through unit vector field
	vec4 result = inPos;
	return result;
}
// vector field for flame effect
vec4 flameVectorField(in vec4 inPos)
{
	// attributes
	float inwardForce = 0.03;
	float upwardForce = 1.2;
	
	// paramaterize output
	float x = -inPos.x * inPos.y * inwardForce;
	float y = upwardForce;
	float z = -inPos.z * inPos.y * inwardForce;
	
	// finalize output
	return vec4(x, y, z, inPos.w);
}
// vector field for explosion
vec4 flowVectorField(in vec4 inPos)
{
	// paramaterize output
	float x = sin(inPos.z * 0.2) + 0.6;
	float y = sin(inPos.z * 0.3) * 2.0;
	float z = 5.2;
	
	// finalize output
	return vec4(x, y, z, inPos.w);
}

// Apply velocity to a particle's position
void calculatePosition(in vec4 inPosition, inout vec4 velocity, out vec4 outPosition)
{
	outPosition = vec4(inPosition.xyz + velocity.xyz, inPosition.w);
}

void main()
{
	
	// get simulation data from last frame -------------------------------------------------
	uint storePos = gl_GlobalInvocationID.x;
	
	// simulate each particle one more step ------------------------------------------------
	
	// get simulation data from last frame
	vec4 prevPos = ParticleCalc.data[storePos].position;
	//vec4 prevVel = ParticleCalc.data[storePos].velocity;
	vec4 prevVel;
	vec4 newPos;
	
	// PARTICLE EFFECT PROPERTIES
	float particleSpeed = 0.015;
	
	// default emission shape
	// circle
	//vec3 defaultPosition = vec3(cos(storePos) * 3.0, 0.0, sin(storePos) * 3.0);
	// spiral
	vec3 defaultPosition = vec3(0.005 * float(storePos) * cos(storePos), 0.0, 0.005 * float(storePos) * sin(storePos));
	// line on x-axis
	//vec3 defaultPosition = vec3(float(storePos) * 0.03, 0.0, 0.0);
	
	// noise properties
	float scrollSpeed = 0.2;
	float frequency = 0.3;
	//vec3 intensity = vec3(prevPos.x * 0.001 + prevPos.z * 0.003, 0.0, 0.0);
	vec3 intensity = vec3(0.025, prevPos.y * 0.002, 0.025);
	//vec3 intensity = vec3(prevPos.y * 0.001 + 0.01, prevPos.y * 0.003, prevPos.y * 0.001 + 0.01);
		
	// handle particle lifetime
	float randValue;
	checkLifetime(prevPos, prevVel, storePos, defaultPosition, randValue);
	float lifetime = prevPos.w - randValue;
	
	// pick a vector field
	//prevVel = flowVectorField(prevPos) * particleSpeed;
	prevVel = flameVectorField(prevPos) * particleSpeed;
	//prevVel = radialVectorField(prevPos) * particleSpeed;
	
	// add noise to velocity
	prevVel += simplexNoise(prevPos, scrollSpeed, frequency, intensity);

	// add velocity to position
	calculatePosition(prevPos, prevVel, newPos);
	ParticleCalc.data[storePos].position = newPos;
	
	// write particle position and color to output buffer -----------------------------------
	ParticleOut.data[storePos].position = ParticleCalc.data[storePos].position;
	
	// color
	float t = mod((uTime * 1.0) + storePos, 250.0);
	
	float lightness = 0.125;
	//ParticleOut.data[storePos].color = hueshift(vec3(1.0, lightness, lightness), t * 0.0005);
	//ParticleOut.data[storePos].color = hueshift(vec3(1.0, 0.0, 0.0), prevPos.z * 0.007 + 0.7);
	//ParticleOut.data[storePos].color = vec4(1.0);
	
	float midDist = distance(prevPos, vec4(0.0, prevPos.y, 0.0, prevPos.w));
	vec4 midColor = hueshift(vec3(1.0, lightness, lightness), midDist * -0.03 + 0.15);
	vec4 lifeColor = hueshift(vec3(1.0, lightness, lightness), lifetime * 0.03);
	ParticleOut.data[storePos].color = mix(midColor, lifeColor, 0.3);
}