// utility functions
// conversions adapted from here: https://www.niwa.nu/2013/05/math-behind-colorspace-conversions-rgb-hsl/
// and here: https://www.rapidtables.com/convert/color/hsl-to-rgb.html
vec3 rgb2hsl(in vec3 rgb)
{
    vec3 hsl;
    
    // perform RGB to HSL calculation
    float minimum = rgb.r;
    for (int i = 1; i < 3; i++) {
        if (rgb[i] < minimum) {
        	minimum = rgb[i];   
        }
    }
    float maximum = rgb.r;
    for (int i = 1; i < 3; i++) {
        if (rgb[i] > maximum) {
        	maximum = rgb[i];   
        }
    }
    // calculate luminance
    hsl.z = (maximum + minimum) / 2.0;
    // calculate saturation
    if (maximum - minimum == 0.0) {
    	hsl.y = 0.0;    
    }
    else {
        hsl.y = (maximum - minimum) / (1.0 - abs(2.0 * hsl.z - 1.0));
    }
    
    // calculate hue
    if (maximum - minimum == 0.0) {
    	hsl.x = 0.0;    
    }
    else if (maximum == rgb.r) {
        hsl.x = (rgb.g - rgb.b) / (maximum - minimum);
    }
    else if (maximum == rgb.g) {
        hsl.x = 2.0 + (rgb.b - rgb.r) / (maximum - minimum);
    }
    else if (maximum == rgb.b) {
        hsl.x = 4.0 + (rgb.r - rgb.g) / (maximum - minimum);
    }
    hsl.x *= 60.0;
    if (hsl.x < 0.0) {
        hsl.x += 360.0;
    }
    // map back to [0,1]
    hsl.x /= 360.0;
    
    return hsl;
    
}
// adapted from here: https://www.rapidtables.com/convert/color/hsl-to-rgb.html
vec3 hsl2rgb(in vec3 hsl)
{
 
    vec3 rgb;
    
    // create temporary variables for readability
    float h = hsl.x * 360.0;
    float s = hsl.y;
    float l = hsl.z;
    float c = (1.0 - abs(2.0 * l - 1.0)) * s;
    float x = c * (1.0 - abs(mod((h / 60.0), 2.0) - 1.0));
    float m = l - c / 2.0;
    
    // determine individual RGB values
    vec3 temp;
    if (h < 60.0) {
        temp = vec3(c, x, 0.0);
    }
    else if (h >= 60.0 && h < 120.0) {
        temp = vec3(x, c, 0);
    }
    else if (h >= 120.0 && h < 180.0) {
        temp = vec3(0, c, x);
    }
    else if (h >= 180.0 && h < 240.0) {
        temp = vec3(0, x, c);
    }
    else if (h >= 240.0 && h < 300.0) {
        temp = vec3(x, 0, c);
    }
    else if (h >= 300.0) {
        temp = vec3(c, 0, x);
    }
    // finalize RGB values
    rgb = vec3(temp.x + m, temp.y + m, temp.z + m);
    
    return rgb;
    
}
// hue shift function
vec3 hueshift(in vec3 orig, in float shift)
{
    vec3 shifted = rgb2hsl(orig);
    shifted.x += shift;
    if (shifted.x > 1.0) {
        shifted.x -= 1.0;
    }
    if (shifted.x < 0.0) {
        shifted.x += 1.0;
    }
    shifted = hsl2rgb(shifted);
    return shifted;
}

// effect 0: static gradient
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    
    // R -> 0.8
    // G -> horizontal
    // B -> vertical
    // A -> 1
    // create standardized coordinates
    vec2 uv = fragCoord / resolution;
    // return a gradient
    return vec4(0.8, uv.x, uv.y, 1.0);
    
}

// effect 1: static checkerboard
// NOTE: this is likely very inefficient due to the amount of sin calls
vec4 myEffect1(in vec2 fragCoord, in vec2 resolution)
{
    // modifiable properties
    float widthModifier = 5.0;
    
    // declare final color
    vec4 myColor;
    
    // create imaginary horizontal lines across the screen
    // if we are on the first set of imaginary rows:
    if (sin(fragCoord.y / widthModifier) > 0.0) {
        // create vertical lines of black and white
        if (sin(fragCoord.x / widthModifier) > 0.0) {
            myColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        else {
            myColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }
    // if we are on the other set of imaginary rows:
    else {
        // create vertical lines of black and white except opposite of the other rows
        if (sin(fragCoord.x / widthModifier) <= 0.0) {
            myColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        else {
            myColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }
    
    return myColor;
}

// effect 2: breathing circle
vec4 myEffect2(in vec2 fragCoord, in vec2 resolution)
{
    
    // modifiable properties
    float circleSize = 2.0;
    float breatheAmount = 0.65;
    float colorIntensity = 0.5;
    float colorCycleSpeed = 0.1f;
    
    // declare final color and supporting colors
    vec4 myColor;
    //vec3 currentColor = 0.5 + colorIntensity*cos(iTime*colorCycleSpeed+vec3(0,2,4));
    vec3 currentColor = hueshift(vec3(1.0, 0.0, 0.0), fract(iTime * colorCycleSpeed));
    vec3 complementaryColor = vec3(1.0, 1.0, 1.0) - currentColor;
    
    // find center coordinate of the screen
    vec2 center = vec2(resolution / 2.0);
    
    // determine radius of the circle and distance from the center point
    float radius = 100.0 * (sin(iTime) + circleSize) * breatheAmount;
    float dist = distance(fragCoord, center);
    
    // if we are inside the circle
    if (dist < radius) {
        // create radial gradient
        
        // get value [0, 2] based on distance from center
        float normalizedDistance = dist / radius * 2.0;
        
        // create a color based on this dist and the current color
        //vec3 extraColor = vec3(currentColor.x, complementaryColor.x, normalizedDistance);
        vec3 extraColor = hueshift(currentColor, 0.25);
        
        if (normalizedDistance < 1.0) { // inner gradient color band
        	currentColor = mix(currentColor, extraColor, normalizedDistance);
        }
        else { // outer gradient color band
            currentColor = mix(extraColor, complementaryColor, normalizedDistance - 1.0);
        }
        myColor = vec4(currentColor, 1.0);
    }
    // not in the circle
    else {
    	myColor = vec4(complementaryColor, 1.0);
    }
    
    return myColor;
    
}

// effect 3: psychedelic spiral
// method for creating a spiral sampled from user brainjam: https://stackoverflow.com/questions/4638317/how-to-implement-this-rotating-spiral-in-webgl
// specifically, I referenced the method for determining angle and amod.
vec4 myEffect3(in vec2 fragCoord, in vec2 resolution)
{
    vec3 myColor = vec3(1.0, 0.0, 0.0);
    
    // customizable properties
    float breatheSpeed = 0.5;
    float swirlDepth = 1.4;
    float rotateSpeed = 50.0;
    float swirliness = 120.0;
    float colorRotateSpeed = 7.0;
    
    // create normalized pixel coordinates, scale to aspect ratio and center on screen
    vec2 uv = fragCoord / resolution - 0.5;
    uv.x *= resolution.x / resolution.y;
    
    // convert to polar
    float radius = length(uv);
    float theta = 0.0;
    if (uv.x != 0.0 && uv.y != 0.0){
        theta = degrees(atan(uv.y, uv.x)) ;
    }
    // create a parameter for breathing
    float p = swirlDepth * sin(iTime * breatheSpeed);
    
    float amod = mod(theta + rotateSpeed * iTime - swirliness * p * log(radius), 30.0);
    if (amod<15.0){
        myColor = vec3( 0.0, 0.0, 0.0);
    } else {
        myColor = hueshift(myColor, fract(theta / 360.0) + fract(iTime * colorRotateSpeed));
        // make it darker in the center for a tunnel effect
        vec2 center = resolution / 2.0;
        vec2 topMiddle = vec2(resolution.x / 2.0, resolution.y);
        myColor *= pow(radius / distance(center, topMiddle) * 2000.0, 0.9);
    }
    
    return vec4(myColor, 1.0);
    
}

// effect 4: drippy waves
vec4 myEffect4(in vec2 fragCoord, in vec2 resolution)
{
    
    // make final color to return at the end of the function
    vec3 myColor = vec3(0.0);
    vec2 uv = fragCoord / resolution;
    
    // customizable properties
    // wave1 (top)
    float wave1Width = 30.0;
    float wave1Depth = 5.0;
    float wave1DepthAlt = 10.0 + sin(iTime) * 2.0;
    float squiggle = 3.0 + sin(iTime) * 0.4;
    float wave1Yoffset = resolution.y * 0.75 + sin(iTime) * 30.0;
    // wave2 (bottom)
    float wave2Width = 10.0;
    float wave2Depth = 10.0;
    float wave2DepthAlt = 10.0 - sin(iTime) * 2.0;
    float squiggle2 = 1.0 - sin(iTime / 4.0) * 2.0;
    float wave2Yoffset = resolution.y * 0.25;
    // background
    float widthModifier = 15.0;
    float scrollSpeed = 100.0;
    
    // determine y values for each wave
    float wave1value = (sin(fragCoord.x / wave1Width) * wave1DepthAlt + cos(squiggle * (fragCoord.x / wave1Width)) * wave1Depth) + wave1Yoffset;
    float wave2value = (sin(fragCoord.x / wave2Width) * wave2DepthAlt + cos(squiggle2 * (fragCoord.x / wave2Width)) * wave2Depth) + wave2Yoffset;
    
    if (fragCoord.y < wave1value && fragCoord.y > wave2value) {
        myColor = vec3(1.0, 0.0, 0.0);
        myColor = hueshift(myColor, uv.x * 0.1 + fract(iTime * 0.5));
    }
    else {
        // create vertical lines of black and white in the background
        // top half of the screen
        if (uv.y > 0.5) {
            if (sin((fragCoord.x - iTime * scrollSpeed) / widthModifier) > 0.0) {
                myColor = vec3(1.0, 1.0, 1.0);
            }
            else {
                myColor = vec3(0.0, 0.0, 0.0);
            }
        }
        // bottom half of the screen
        else {
            if (sin((fragCoord.x + iTime * scrollSpeed) / widthModifier) > 0.0) {
                myColor = vec3(1.0, 1.0, 1.0);
            }
            else {
                myColor = vec3(0.0, 0.0, 0.0);
            }
        }
    }
    
    return vec4(myColor, 1.0);
    
}

vec4 testEffect(in vec2 fragCoord, in vec2 resolution)
{
    // how to use arrays:
    float myArray[6] = float[6](1.0, 2.0, 1.0, 2.0, 1.0, 2.0);
    myArray[0] = 1.0;
    
    // all of these are equal:
    //color[0] = 1.0;  |  color.x = 1.0;  |  color.r = 1.0;
    
    // output gradient
    //vec2 uv = fragCoord / resolution;
    //return vec4(0.0, uv.x, uv.y, 1.0);
    
    vec3 originalRGB = vec3(171.0/255.0, 152.0/255.0, 84.0/255.0);
    vec3 converted = hsl2rgb(rgb2hsl(originalRGB));
    vec3 shifted = hueshift(converted, 0.1);
    return vec4(shifted, 1.0);
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
 	
    fragColor = myEffect0(fragCoord, iResolution.xy);
    //fragColor = myEffect1(fragCoord, iResolution.xy);
    //fragColor = myEffect2(fragCoord, iResolution.xy);
    //fragColor = myEffect3(fragCoord, iResolution.xy);
    //fragColor = myEffect4(fragCoord, iResolution.xy);
    //fragColor = testEffect(fragCoord, iResolution.xy);
    
}