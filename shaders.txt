// effect 0: static gradient
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    
    // R -> 0.8
    // G -> horizontal
    // b -> vertical
    // a -> 1
    vec2 uv = fragCoord / resolution;
    return vec4(0.8, uv.x, uv.y, 1.0);
    
}

// effect 1: static checkerboard
// NOTE: this is likely very inefficient due to the amount of sin calls
vec4 myEffect1(in vec2 fragCoord, in vec2 resolution)
{
    // modifiable properties
    float widthModifier = 5.0;
    
    // declare final color
    vec4 myColor;
    
    // create imaginary horizontal lines across the screen
    // if we are on the first set of imaginary rows:
    if (sin(fragCoord.y / widthModifier) > 0.0) {
        // create vertical lines of black and white
        if (sin(fragCoord.x / widthModifier) > 0.0) {
            myColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        else {
            myColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }
    // if we are on the other set of imaginary rows:
    else {
        // create vertical lines of black and white except opposite of the other rows
        if (sin(fragCoord.x / widthModifier) <= 0.0) {
            myColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        else {
            myColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }
    
    return myColor;
}

// effect 2: breathing circle
vec4 myEffect2(in vec2 fragCoord, in vec2 resolution)
{
    
    // modifiable properties
    float circleSize = 3.0;
    float breatheAmount = 0.3;
    float colorIntensity = 0.5;
    float colorCycleSpeed = 1.0f;
    
    // declare final color and supporting colors
    vec4 myColor;
    vec3 currentColor = 0.5 + colorIntensity*cos(iTime*colorCycleSpeed+vec3(0,2,4));
    vec3 complementaryColor = vec3(1.0, 1.0, 1.0) - currentColor;
    
    // find center coordinate of the screen
    vec2 center = vec2(resolution / 2.0);
    
    // determine radius of the circle and distance from the center point
    float radius = 100.0 * (sin(iTime) + circleSize) * breatheAmount;
    float dist = distance(fragCoord, center);
    
    if (dist < radius) {
        myColor = vec4(currentColor, 1.0);
    }
    else {
    	myColor = vec4(complementaryColor, 1.0);
    }
    
    return myColor;
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
 	
    fragColor = myEffect2(fragCoord, iResolution.xy);
    
    /*
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    fragColor = vec4(col,1.0);
*/
}