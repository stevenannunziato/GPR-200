#version 450

#ifdef GL_ES
precision highp float;
#endif

layout (location = 0) out vec4 rtFragColor;

uniform float uTime;

in vec4 vNormal;
in vec4 vVertexPos;
in vec4 vEyePos;

// UTILITY FUNCTIONS ----------------------
float square(float n)
{
	return n * n;
}
float pow16(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	return n;
}
float pow32(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	return n;
}
float pow64(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	n *= n; // power = 64
	return n;
}

// LIGHTING ---------------------------
// structure for lights
struct pointLight
{
	vec4 center;
	vec4 color;
	float intensity;
};
void initPointLight(out pointLight light, in vec4 center, in vec4 color, in float intensity)
{
	light.center = center;
	light.color = color;
	light.intensity = intensity;
}

float calcDiffuse(in pointLight light, in vec3 position, in vec3 normal, in vec3 lightVector)
{
    // lambertian reflectance
    float lightDist = sqrt(dot(lightVector, lightVector));
    float diffuseCoefficient = max(0.0, dot(normal, lightVector));
    // attenuation (light falloff)
    float invIntensity = 1.0 / light.intensity;
    float attenuatedIntensity = 1.0 / (1.0 + (lightDist * invIntensity) + square(lightDist * invIntensity));
    return diffuseCoefficient * attenuatedIntensity;
}
// calculations for specular highlights
float phongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)
{
    // phong reflectance
    vec3 reflectedLight = reflect(-lightVector, normal);
    float specularCoefficient = max(0.0, dot(viewVector, reflectedLight));
    return pow64(specularCoefficient);
}

vec4 calcLighting(in pointLight[3] lights, vec4 position, vec3 normal, vec3 eyePos)
{
	
	// lighting properties
	vec4 ambientColor = vec4(1.0, 1.0, 1.0, 1.0);
	float ambientIntensity = 0.05;
	vec4 specularReflectionColor = vec4(1.0);
	vec4 diffuseColor = vec4(1.0);

	vec4 finalAmbient = ambientIntensity * ambientColor;
    vec4 summedColor = vec4(0.0);
    // loop through each light
    for (int i = lights.length() - 1; i >= 0; --i) {

    	vec3 lightVector = lights[i].center.xyz - position.xyz;
    	float invDist = 1.0 / sqrt(dot(lightVector, lightVector));
    	lightVector *= invDist; // light vector is now normalized
        vec3 viewVector = eyePos - position.xyz; // not normalized
        float invLength = 1.0 / sqrt(dot(viewVector, viewVector));
        viewVector *= invLength; // normalized

        // first calculate diffuse intensity
        float diffuseIntensity = calcDiffuse(lights[i], position.xyz, normal, lightVector);

        // next calculate specular intensity
        float specularIntensity = phongSpecular(lightVector, viewVector, normal);

        // final calculation
        summedColor += (diffuseIntensity * diffuseColor + specularIntensity * specularReflectionColor) * lights[i].color;
    }
    return finalAmbient + summedColor;
}

void main()
{
	// initialize lights
	pointLight light1;
	initPointLight(light1, vec4(1.0, 4.5, 1.0, 0.0), vec4(1.0), 10.0);
	pointLight[3] lights;
	lights[0] = light1;

	// calculate lighting
	vec4 litColor = calcLighting(lights, vVertexPos, vNormal.xyz, vEyePos.xyz);
	rtFragColor = litColor;
}