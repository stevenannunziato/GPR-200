#version 450

#ifdef GL_ES
precision highp float;
#endif

layout (location = 0) out vec4 rtFragColor;

uniform sampler2D uCelTex;
uniform float uTime;
uniform vec3 eyePosition;
uniform vec4 mousePosition;

in vec4 vNormal;
in vec4 vVertexPos;

// UTILITY FUNCTIONS ----------------------

// hueshift function adapted from user mAlk:
// https://www.shadertoy.com/view/MsjXRt
vec4 hueShift(in vec3 Color, in float Shift)
{
    vec3 P = vec3(0.55735) * dot(vec3(0.55735), Color);
    vec3 U = Color - P;
    vec3 V = cross(vec3(0.55735), U);
    
    Color = U * cos(Shift * 6.2832) + V * sin(Shift * 6.2832) + P;
    return vec4(Color, 1.0);
}

float square(float n)
{
	return n * n;
}
float pow16(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	return n;
}
float pow32(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	return n;
}
float pow64(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	n *= n; // power = 64
	return n;
}

// LIGHTING ---------------------------

// structure for lights
struct pointLight
{
	vec4 center;
	vec4 color;
	float intensity;
};
void initPointLight(out pointLight light, in vec4 center, in vec4 color, in float intensity)
{
	light.center = center;
	light.color = color;
	light.intensity = intensity;
}

// method for cel shading referenced here:
// https://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S12/final_projects/hutchins_kim.pdf
vec4 calcCelColor(in pointLight light, in vec3 position, in vec3 normal)
{
	vec3 lightVector = light.center.xyz - position.xyz;
    float invDist = 1.0 / sqrt(dot(lightVector, lightVector));
    lightVector *= invDist; // light vector is now normalized
    
	float diffuseCoefficient = dot(normal, lightVector);
	
	// sample 1D texture;
	vec2 uv = vec2(diffuseCoefficient * 0.5 + 0.5, 0.0);
	vec4 color = texture(uCelTex, uv);
	return color;
	
}

// lambertian reflectance
float calcDiffuse(in pointLight light, in vec3 position, in vec3 normal, in vec3 lightVector)
{

    float lightDist = sqrt(dot(lightVector, lightVector));
    float diffuseCoefficient = max(0.0, dot(normal, lightVector));
    
    // attenuation (light falloff)
    float invIntensity = 1.0 / light.intensity;
    float attenuatedIntensity = 1.0 / (1.0 + (lightDist * invIntensity) + square(lightDist * invIntensity));
    return diffuseCoefficient * attenuatedIntensity;
    
}
// calculations for specular highlights
float phongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)
{
    // phong reflectance
    vec3 reflectedLight = reflect(-lightVector, normal);
    float specularCoefficient = max(0.0, dot(viewVector, reflectedLight));
    return pow64(specularCoefficient);
}

vec4 calcLighting(in pointLight[1] lights, vec4 position, vec3 normal, vec3 eyePos)
{
	
	// lighting properties
	vec4 ambientColor = vec4(1.0, 1.0, 1.0, 1.0);
	float ambientIntensity = 0.05;
	vec4 specularReflectionColor = vec4(1.0);
	vec4 diffuseColor = vec4(1.0);

	vec4 finalAmbient = ambientIntensity * ambientColor;
    vec4 summedColor = vec4(0.0);
    // loop through each light
    for (int i = lights.length() - 1; i >= 0; --i) {

    	vec3 lightVector = lights[i].center.xyz - position.xyz;
    	float invDist = 1.0 / sqrt(dot(lightVector, lightVector));
    	lightVector *= invDist; // light vector is now normalized
        vec3 viewVector = eyePos - position.xyz; // not normalized
        float invLength = 1.0 / sqrt(dot(viewVector, viewVector));
        viewVector *= invLength; // normalized
        
        // cel
        vec4 celColor = calcCelColor(lights[i], position.xyz, normal) * lights[i].color;
        
        // gooch
        float diffuseIntensity = calcDiffuse(lights[i], position.xyz, normal, lightVector);
        vec4 goochColor = mix(vec4(0.04, 0.0, 0.1, 1.0), vec4(1.0, 0.8, 0.0, 1.0), diffuseIntensity);
        //summedColor += mix(vec4(0.01, 0.0, 0.06, 1.0), lights[i].color, diffuseIntensity);
        
        summedColor += mix(celColor, goochColor, mousePosition.b);
        //summedColor += celColor;
        
		/*
		// Phong
        // first calculate diffuse intensity
        float diffuseIntensity = calcDiffuse(lights[i], position.xyz, normal, lightVector);

        // next calculate specular intensity
        float specularIntensity = phongSpecular(lightVector, viewVector, normal);

        // final calculation
        summedColor += (diffuseIntensity * diffuseColor + specularIntensity * specularReflectionColor) * lights[i].color;
        */
    }
    return finalAmbient + summedColor;
}

void main()
{
	// initialize lights
	vec4 lightColor = hueShift(vec3(0.9, 0.6, 0.6), uTime * 0.06);
	pointLight light1;
	initPointLight(light1, vec4(sin(uTime) * 5.0, 6.0, cos(uTime) * 5.0, 1.0), lightColor, 4.0);
	pointLight[1] lights;
	lights[0] = light1;

	// calculate lighting
	vec4 litColor = calcLighting(lights, vVertexPos, vNormal.xyz, eyePosition);
	
	rtFragColor = litColor;
	
	// test
	/*vec4 ndc = vPosClip / vPosClip.w;
	rtFragColor = ndc * 0.5 + 0.5;
	rtFragColor.b = 0.0;*/
}