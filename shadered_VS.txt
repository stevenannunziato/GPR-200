#version 300 es

// vertex shader main duty: process attributes
// position in space
// surface normal
// 2D texture coordinate

//in vec4 aPosition;
// w = 1 for points
layout (location = 0) in vec4 aPosition; // position is the first attribute
layout (location = 1) in vec3 aNormal;
// 2D uv texture coordinate
//layout (location = 2) in vec2 aTexCoord;
layout (location = 2) in vec4 aTexCoord;

// TRANSFORM UNIFORMS
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uViewProjectionMatrix;
uniform sampler2D earth;


// VARYINGS

// Per-vertex: send final color
// out vec4 vColor;
// Per-fragment: send to FS to calculate color
out vec4 vNormal;

//out vec2 vTexCoord;
out vec4 vTexCoord;

// varyings for phong reflectence
out vec4 phongViewColor;

// utility
float square(float n)
{
	return n * n;
}
float pow16(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	return n;
}
float pow32(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	return n;
}
float pow64(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	n *= n; // power = 64
	return n;
}

// structure for lights
struct pointLight
{
	vec4 center;
	vec4 color;
	float intensity;
};
void initPointLight(out pointLight light, in vec4 center, in vec4 color, in float intensity)
{
	light.center = center;
	light.color = color;
	light.intensity = intensity;
}

float calcDiffuse(in pointLight light, in vec3 position, in vec3 normal, out vec3 lightVector)
{
    // lambertian reflectance
    lightVector = light.center.xyz - position;
    float lightDist = sqrt(dot(lightVector, lightVector));
    float invDist = 1.0 / lightDist;
    lightVector *= invDist; // light vector is now normalized
    float diffuseCoefficient = max(0.0, dot(normal, lightVector));
    // attenuation (light falloff)
    float invIntensity = 1.0 / light.intensity;
    float attenuatedIntensity = 1.0 / (1.0 + (lightDist * invIntensity) + square(lightDist * invIntensity));
    return diffuseCoefficient * attenuatedIntensity;
}
// calculations for specular highlights
float phongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)
{
    // phong reflectance
    vec3 reflectedLight = reflect(-lightVector, normal);
    float specularCoefficient = max(0.0, dot(viewVector, reflectedLight));
    return pow16(specularCoefficient);
}

vec4 calcLighting(pointLight[3] lights, vec4 position, vec3 normal)
{
	// lighting properties
	vec4 ambientColor = vec4(1.0, 0.9, 1.0, 1.0);
	float ambientIntensity = 0.00;
	vec4 specularReflectionColor = vec4(1.0);
	vec4 diffuseColor = vec4(1.0);

	vec4 finalAmbient = ambientIntensity * ambientColor;
    vec4 summedColor = vec4(0.0);
    // loop through each light
    for (int i = lights.length() - 1; i >= 0; --i) {

        vec3 lightVector = lights[i].center.xyz - position.xyz;
        vec3 viewVector = vec3(0.0) - position.xyz; // not normalized
        float invLength = 1.0 / sqrt(dot(viewVector, viewVector));
        viewVector *= invLength; // normalized

        // first calculate diffuse intensity
        float diffuseIntensity = calcDiffuse(lights[i], position.xyz, normal, lightVector);

        // next calculate specular intensity
        float specularIntensity = phongSpecular(lightVector, viewVector, normal);

        // final calculation
        summedColor += (diffuseIntensity * diffuseColor + specularIntensity * specularReflectionColor) * lights[i].color;
    }
    return finalAmbient + summedColor;
}

void main()
{
	// NOTES --------------------------------------------------------------------
	// REQUIRED: set this value: gl_Position
	// this is the only thing you have to do in a vertex shader
	// problem: gl_Position is in "clip-space"
	// further: aPosition is in "object-space"
	//gl_Position = aPosition;
	
	// default is object-space
	// position in world-space (nope)
	//vec4 worldPos = uModelMatrix * aPosition;
	//gl_Position = worldPos;
	
	// position in camera-space (still not quite)
	//vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
	//vec4 viewPos = uViewMatrix * worldPos;
	//gl_Position = viewPos;
	
	// position in clip-space (yes)
	//vec4 clipPos = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
	//vec4 clipPos = uViewProjectionMatrix * worldPos;
    //vec4 clipPos = uProjectionMatrix * viewPos;
	
	// POSITION PIPELINE --------------------------------------------------------------------
	mat4 modelViewMatrix = uViewMatrix * uModelMatrix;
	vec4 viewPos = modelViewMatrix * aPosition;
	// vertices are now in view-space
	
	vec4 clipPos = uProjectionMatrix * viewPos;
	gl_Position = clipPos;
	
	// NORMAL PIPELINE --------------------------------------------------------------------
	mat3 normalMatrix = transpose(inverse(mat3(modelViewMatrix)));
	vec3 normCamera = normalMatrix * aNormal;
	
	// LIGHTING PIPELINE --------------------------------------------------------------------
	// define light properties in world space
	pointLight light1, light2, light3;
	initPointLight(light1, vec4(15.0, 0.0, 0.0, 1.0), vec4(1.0), 9.0);
	initPointLight(light2, vec4(-15.0, 0.0, .0, 1.0), vec4(1.0), 15.0);
	initPointLight(light3, vec4(0.0, 15.0, 0.0, 1.0), vec4(1.0), 25.0);
	pointLight[3] lights;
	lights[0] = light1;
	lights[1] = light2;
	lights[2] = light3;
	// convert light properties to view space
	light1.center = light1.center * uViewMatrix;
	light2.center = light2.center * uViewMatrix;
	light3.center = light3.center * uViewMatrix;
	// view-space phong reflectence
	phongViewColor = calcLighting(lights, viewPos, normCamera);
	
	// TEXCOORD PIPELINE --------------------------------------------------------------------
	mat4 atlasMat = mat4(1.0, 0.0, 0.0, 0.0,
						 0.0, 1.0, 0.0, 0.0,
						 0.0, 0.0, 1.0, 0.0,
						 0.0, 0.0, 0.0, 1.0);
	vec4 uv_atlas = atlasMat * aTexCoord;
	
	// texture sphere
	phongViewColor *= texture(earth, uv_atlas.xy);
	
	// VARYINGS --------------------------------------------------------------------
	// Per-vertex: Calculate and output a final color
	// vColor = vec4(aNormal * 0.5 + 0.5, 1.0);
	
	// Per-fragment: pass elements FS needs to calculate final color
	
	//vNormal = vec4(aNormal, 0.0);
	vNormal = vec4(normCamera, 0.0);
	
	// texture coordinates
	vTexCoord = uv_atlas;
	
	// display textures in clip space
	//gl_Position = uProjectionMatrix * modelViewMatrix * aTexCoord;
}