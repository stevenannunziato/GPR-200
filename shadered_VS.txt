#version 300 es

// vertex shader main duty: process attributes
// position in space
// surface normal
// 2D texture coordinate

//in vec4 aPosition;
// w = 1 for points
layout (location = 0) in vec4 aPosition; // position is the first attribute
layout (location = 1) in vec3 aNormal;
// 2D uv texture coordinate
//layout (location = 2) in vec2 aTexCoord;
layout (location = 2) in vec4 aTexCoord;

// TRANSFORM UNIFORMS
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uViewProjectionMatrix;
uniform sampler2D earth;
uniform vec3 eyePosition;
uniform float time;

// VARYINGS

// Per-vertex: send final color
// out vec4 vColor;
// Per-fragment: send to FS to calculate color
out vec4 vNormal;

//out vec2 vTexCoord;
out vec4 vTexCoord;

// varyings for phong reflectence
out vec4 phongViewColor;
out vec4 phongObjectColor;
// per-fragment calculations
out vec4 light1posView;
out vec4 light2posView;
out vec4 light3posView;
out vec4 light1posObj;
out vec4 light2posObj;
out vec4 light3posObj;
out float light1intensity;
out float light2intensity;
out float light3intensity;
out vec4 vertexPosView;
out vec3 normalView;
out vec4 vertexPosObj;
out vec3 normalObj;
out vec3 eyePosView;
out vec3 eyePosObj;

// utility
float square(float n)
{
	return n * n;
}
float pow16(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	return n;
}
float pow32(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	return n;
}
float pow64(float n)
{
	n *= n; // power = 2
	n *= n; // power = 4
	n *= n; // power = 8
	n *= n; // power = 16
	n *= n; // power = 32
	n *= n; // power = 64
	return n;
}

// structure for lights
struct pointLight
{
	vec4 center;
	vec4 color;
	float intensity;
};
void initPointLight(out pointLight light, in vec4 center, in vec4 color, in float intensity)
{
	light.center = center;
	light.color = color;
	light.intensity = intensity;
}

float calcDiffuse(in pointLight light, in vec3 position, in vec3 normal, in vec3 lightVector)
{
    // lambertian reflectance
    float lightDist = sqrt(dot(lightVector, lightVector));
    float diffuseCoefficient = max(0.0, dot(normal, lightVector));
    // attenuation (light falloff)
    float invIntensity = 1.0 / light.intensity;
    float attenuatedIntensity = 1.0 / (1.0 + (lightDist * invIntensity) + square(lightDist * invIntensity));
    return diffuseCoefficient * attenuatedIntensity;
}
// calculations for specular highlights
float phongSpecular(in vec3 lightVector, in vec3 viewVector, in vec3 normal)
{
    // phong reflectance
    vec3 reflectedLight = reflect(-lightVector, normal);
    float specularCoefficient = max(0.0, dot(viewVector, reflectedLight));
    return pow16(specularCoefficient);
}

vec4 calcLighting(pointLight[3] lights, vec4 position, vec3 normal, vec3 eyePos)
{
	// lighting properties
	vec4 ambientColor = vec4(1.0, 1.0, 1.0, 1.0);
	float ambientIntensity = 0.05;
	vec4 specularReflectionColor = vec4(1.0);
	vec4 diffuseColor = vec4(1.0);

	vec4 finalAmbient = ambientIntensity * ambientColor;
    vec4 summedColor = vec4(0.0);
    // loop through each light
    for (int i = lights.length() - 1; i >= 0; --i) {

    	vec3 lightVector = lights[i].center.xyz - position.xyz;
    	float invDist = 1.0 / sqrt(dot(lightVector, lightVector));
    	lightVector *= invDist; // light vector is now normalized
        vec3 viewVector = eyePos - position.xyz; // not normalized
        float invLength = 1.0 / sqrt(dot(viewVector, viewVector));
        viewVector *= invLength; // normalized

        // first calculate diffuse intensity
        float diffuseIntensity = calcDiffuse(lights[i], position.xyz, normal, lightVector);

        // next calculate specular intensity
        float specularIntensity = phongSpecular(lightVector, viewVector, normal);

        // final calculation
        summedColor += (diffuseIntensity * diffuseColor + specularIntensity * specularReflectionColor) * lights[i].color;
    }
    return finalAmbient + summedColor;
}

void main()
{
	// NOTES --------------------------------------------------------------------
	
	// REQUIRED: set this value: gl_Position
	// this is the only thing you have to do in a vertex shader
	// problem: gl_Position is in "clip-space"
	// further: aPosition is in "object-space"
	//gl_Position = aPosition;
	
	// default is object-space
	// position in world-space (nope)
	//vec4 worldPos = uModelMatrix * aPosition;
	//gl_Position = worldPos;
	
	// position in camera-space (still not quite)
	//vec4 viewPos = uViewMatrix * uModelMatrix * aPosition;
	//vec4 viewPos = uViewMatrix * worldPos;
	//gl_Position = viewPos;
	
	// position in clip-space (yes)
	//vec4 clipPos = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;
	//vec4 clipPos = uViewProjectionMatrix * worldPos;
    //vec4 clipPos = uProjectionMatrix * viewPos;
	
	// POSITION PIPELINE --------------------------------------------------------------------
	
	// animate vertex positions
	vec4 aPos = aPosition;
	aPos.y *= 1.5 + sin(time) * 0.5;
	aPos.x *= 1.5 + sin(time + 3.14) * 0.5;
	
	mat4 modelViewMatrix = uViewMatrix * uModelMatrix;
	vec4 viewPos = modelViewMatrix * aPos;
	// vertices are now in view-space
	
	vec4 clipPos = uProjectionMatrix * viewPos;
	gl_Position = clipPos;
	
	// NORMAL PIPELINE --------------------------------------------------------------------
	mat3 normalMatrix = transpose(inverse(mat3(modelViewMatrix)));
	vec3 normCamera = normalMatrix * aNormal;
	
	// LIGHTING PIPELINE --------------------------------------------------------------------
	
	// define light properties in world space
	pointLight light1, light2, light3;
	initPointLight(light1, vec4(15.0, 0.0, 9.0, 1.0), vec4(1.0), 20.0);
	initPointLight(light2, vec4(-15.0, 0.0, 0.0, 1.0), vec4(1.0), 15.0);
	initPointLight(light3, vec4(0.0, 15.0, 0.0, 1.0), vec4(1.0), 25.0);
	
	// convert light properties to view space
	pointLight light1View = light1;
	pointLight light2View = light2;
	pointLight light3View = light3;
	light1View.center = uViewMatrix * light1.center;
	light2View.center = uViewMatrix * light2.center;
	light3View.center = uViewMatrix * light3.center;
	pointLight[3] lightsView;
	lightsView[0] = light1View;
	lightsView[1] = light2View;
	lightsView[2] = light3View;
	
	// convert light properties to object space
	pointLight light1Object = light1;
	pointLight light2Object = light2;
	pointLight light3Object = light3;
	light1Object.center = inverse(uViewMatrix) * light1.center;
	light2Object.center = inverse(uViewMatrix) * light2.center;
	light3Object.center = inverse(uViewMatrix) * light3.center;
	pointLight[3] lightsObject;
	lightsObject[0] = light1Object;
	lightsObject[1] = light2Object;
	lightsObject[2] = light3Object;
	
	// view-space phong reflectence
	// this is currently wrong
	vec4 camPos = uViewMatrix * vec4(eyePosition, 1.0);
	//camPos = vec4(0.0);
	phongViewColor = calcLighting(lightsView, viewPos, normCamera, camPos.xyz);
	
	// object-space phong reflectence
	phongObjectColor = calcLighting(lightsObject, aPosition, aNormal, eyePosition);
	
	// TEXCOORD PIPELINE --------------------------------------------------------------------
	mat4 atlasMat = mat4(1.0, 0.0, 0.0, 0.0,
						 0.0, 1.0, 0.0, 0.0,
						 0.0, 0.0, 1.0, 0.0,
						 0.0, 0.0, 0.0, 1.0);
	vec4 uv_atlas = atlasMat * aTexCoord;
	
	// texture sphere
	vec4 earthColor = texture(earth, uv_atlas.xy);
	phongViewColor *= earthColor;
	phongObjectColor *= earthColor;
	
	// VARYINGS --------------------------------------------------------------------
	// Per-vertex: Calculate and output a final color
	// vColor = vec4(aNormal * 0.5 + 0.5, 1.0);
	
	// Per-fragment: pass elements FS needs to calculate final color
	
	//vNormal = vec4(aNormal, 0.0);
	vNormal = vec4(normCamera, 0.0);
	
	// texture coordinates
	vTexCoord = uv_atlas;
	
	// set varyings for phong per-frag
	light1posView = light1View.center;
	light2posView = light2View.center;
	light3posView = light3View.center;
	light1posObj = light1Object.center;
	light2posObj = light2Object.center;
	light3posObj = light3Object.center;
	light1intensity = light1.intensity;
	light2intensity = light2.intensity;
	light3intensity = light3.intensity;
	vertexPosView = viewPos;
	normalView = normCamera;
	vertexPosObj = aPosition;
	normalObj = aNormal;
	eyePosView = camPos.xyz;
	eyePosObj = eyePosition;
	
	// display textures in clip space
	//gl_Position = uProjectionMatrix * modelViewMatrix * aTexCoord;
}